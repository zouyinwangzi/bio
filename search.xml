<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>下载参考基因组及注释文件</title>
    <url>/2020/01/06/downloadgenome/</url>
    <content><![CDATA[<h1 id="下载参考基因组及注释文件"><a href="#下载参考基因组及注释文件" class="headerlink" title="下载参考基因组及注释文件"></a>下载参考基因组及注释文件</h1><p>通常测序生成的reads要与参考基因组或参考转录组进行比对，所以首先需要获取参考基因组和参考转录组信息。</p>
<a id="more"></a>

<h2 id="下载参考基因组"><a href="#下载参考基因组" class="headerlink" title="下载参考基因组"></a>下载参考基因组</h2><h3 id="UCSC下载"><a href="#UCSC下载" class="headerlink" title="UCSC下载"></a>UCSC下载</h3><p><a href="http://hgdownload.soe.ucsc.edu/goldenPath/hg19/bigZips/chromFa.tar.gz" target="_blank" rel="noopener">http://hgdownload.soe.ucsc.edu/goldenPath/hg19/bigZips/chromFa.tar.gz</a></p>
<p>chromFa.tar.gz - The assembly sequence in one file per chromosome.Repeats from RepeatMasker and Tandem Repeats Finder (with period of 12 or less) are shown in lower case; non-repeating sequence is shown in upper case.</p>
<p>合并为一个文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir reference &amp;&amp; cd reference</span><br><span class="line">mkdir -p genome&#x2F;hg19 &amp;&amp; cd genome&#x2F;hg19</span><br><span class="line">nohup wget http:&#x2F;&#x2F;hgdownload.soe.ucsc.edu&#x2F;goldenPath&#x2F;hg19&#x2F;bigZips&#x2F;chromFa.tar.gz &amp;</span><br><span class="line">tar -zvf chromFa.tar.gz</span><br><span class="line">cat *.fa &gt; hg19.fa</span><br><span class="line">rm chr*</span><br></pre></td></tr></table></figure>
<h3 id="EMBL下载"><a href="#EMBL下载" class="headerlink" title="EMBL下载"></a>EMBL下载</h3><p><a href="ftp://ftp.ensembl.org/pub/release-91/fasta/homo_sapiens/dna/" target="_blank" rel="noopener">ftp://ftp.ensembl.org/pub/release-91/fasta/homo_sapiens/dna/</a></p>
<p>目录下有几类文件：<br>分别是<a href="ftp://ftp.ensembl.org/pub/release-91/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz" target="_blank" rel="noopener">primary</a>, toplevel和unmasked (dna)、soft-masked (dna_sm)和masked (dna_rm)。一般选择dna.primary或dna_sm.primary。</p>
<h4 id="为什么选择Primary"><a href="#为什么选择Primary" class="headerlink" title="为什么选择Primary"></a>为什么选择Primary</h4><p>Primary assembly contains all toplevel sequence regions excluding haplotypes and patches. This file is best used for performing sequence similarity searcheswhere patch and haplotype sequences would confuse analysis.</p>
<h4 id="为什么不选择masked"><a href="#为什么不选择masked" class="headerlink" title="为什么不选择masked"></a>为什么不选择masked</h4><p>Masked基因组是指所有重复区和低复杂区被N代替的基因组序列，比对时就不会有reads比对到这些区域。一般不推荐用masked的基因组，因为它造成了信息的丢失，由此带来的一个问题是uniquely比对到masked基因组上的reads实际上可能不是unique的。而且masked基因组还会带来比对错误，使得在允许错配的情况下，本来来自重复区的reads比对到基因组的其它位置。 另外检测重复区和低复杂区的软件不可能是完美的，这就造成遮盖住的重复序列和低复杂区并不一定是100%准确和敏感的</p>
<h4 id="soft-masked基因组"><a href="#soft-masked基因组" class="headerlink" title="soft-masked基因组"></a>soft-masked基因组</h4><p> 是指把所有重复区和低复杂区的序列用小写字母标出的基因组，由于主要的比对软件，比如BWA、bowtie2等都忽略这些soft-mask，直接把小写字母当做大写字母比对，所以使用soft-masked基因组的比对效果和使用unmasked基因组的比对效果是相同的。</p>
<h3 id="NCBI下载"><a href="#NCBI下载" class="headerlink" title="NCBI下载"></a>NCBI下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">codedoc:hg19参考基因组下载</span><br><span class="line"></span><br><span class="line">for i in $(seq 1 22) X Y M;</span><br><span class="line">do wget ftp:&#x2F;&#x2F;ftp.ncbi.nlm.nih.gov&#x2F;genomes&#x2F;Homo_sapiens&#x2F;ARCHIVE&#x2F;BUILD.37.3&#x2F;Assembled_chromosomes&#x2F;seq&#x2F;hs_ref_GRCh37.p5_chr$&#123;i&#125;.fa.gz; </span><br><span class="line">gzip -d hs_ref_GRCh37.p5_chr$&#123;i&#125;.fa.gz;</span><br><span class="line">cat hs_ref_GRCh37.p5_chr$&#123;i&#125;.fa.gz &gt;&gt;hg19.fa;</span><br><span class="line">sleep 10s;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>
<h2 id="下载基因组注释文件"><a href="#下载基因组注释文件" class="headerlink" title="下载基因组注释文件"></a>下载基因组注释文件</h2><h3 id="EMBL下载-1"><a href="#EMBL下载-1" class="headerlink" title="EMBL下载"></a>EMBL下载</h3><h4 id="FTP下载："><a href="#FTP下载：" class="headerlink" title="FTP下载："></a>FTP下载：</h4><p><a href="ftp://ftp.ensembl.org/pub/release-91/gtf/" target="_blank" rel="noopener">ftp://ftp.ensembl.org/pub/release-91/gtf/</a></p>
<h4 id="BioMart下载"><a href="#BioMart下载" class="headerlink" title="BioMart下载:"></a>BioMart下载:</h4><blockquote>
<p>ENSEMBL数据库的BioMart <a href="http://www.ensembl.org/biomart/martview" target="_blank" rel="noopener">http://www.ensembl.org/biomart/martview</a> 工具为下载基因的功能信息、序列信息、结构信息、ID的转换等提供了很大的便利。</p>
</blockquote>
<p>注意在BioMart的Attribute选项里如果选择了蛋白相关的选项，得到的结果中只有蛋白编码基因的信息。如果要下载所有基因信息，请不要选择蛋白相关的选项。</p>
<p>具体使用如下，下载基因相关信息，首先选择Ensembl Genes 89数据集</p>
<h3 id="gencode下载"><a href="#gencode下载" class="headerlink" title="gencode下载"></a>gencode下载</h3><p>就是去<a href="https://mp.weixin.qq.com/s?__biz=MzI1MjU5MjMzNA==&mid=2247484499&idx=1&sn=597d0be97e2438693b96024a83047807&chksm=e9e02df2de97a4e42f5df3f1f82aa805acf7a9657547e5bf4e1ac727c06218e2ee83273b1b36&mpshare=1&scene=1&srcid=0316towHxmDrrwmE6FMeoJSG&pass_ticket=nceEm7i817n%2BiPLgPDIba4NQtkP9XB7RHHGkKnLD%2BniRIuK7F1kXSuoPMdyFqcxf#rd" target="_blank" rel="noopener">教程</a> <a href="http://www.gencodegenes.org/" target="_blank" rel="noopener">gencode数据库</a>下载基因组注释文件</p>
<h3 id="NCBI下载-1"><a href="#NCBI下载-1" class="headerlink" title="NCBI下载"></a>NCBI下载</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hg38</span><br><span class="line">wget ftp:&#x2F;&#x2F;ftp.ncbi.nlm.nih.gov&#x2F;genomes&#x2F;Homo_sapiens&#x2F;GFF&#x2F;ref_GRCh38.p7_top_level.gff3.gz </span><br><span class="line"># hg19</span><br><span class="line">wget ftp:&#x2F;&#x2F;ftp.ncbi.nlm.nih.gov&#x2F;genomes&#x2F;Homo_sapiens&#x2F;ARCHIVE&#x2F;BUILD.37.3&#x2F;GFF&#x2F;ref_GRCh37.p5_top_level.gff3.gz</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>高通量测序</category>
      </categories>
      <tags>
        <tag>二代测序</tag>
        <tag>基因组</tag>
      </tags>
  </entry>
  <entry>
    <title>R语言GDCRNATools工具</title>
    <url>/2020/01/06/GDCRNATools/</url>
    <content><![CDATA[<p>工具包主要做RNA表达量分析，单因素生存分析，富集分析，以及 lncRNA-mRNA的内源竞争RNA分析。ceRNA（competing endogenous RNAs,内源竞争RNA），已知microRNA可以通过结合mRNA导致基因沉默，而ceRNA可以通过竞争性地结合microRNA来调节基因表达。ceRNA可以通过应答元件（microRNA response elements，MREs)与microRNA结合从而影响microRNA导致的基因沉默，这揭示了一条RNA-&gt;microRNA调节通路的存在，具有重大生物意义</p>
<a id="more"></a>
<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p><a href="https://github.com/Jialab-UCR/GDCRNATools" target="_blank" rel="noopener">软件github链接</a></p>
<h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> /*  首先需要安装依赖包,如下列表  */  </span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span>(“https://bioconductor.org/biocLite.R”)  </span><br><span class="line"><span class="comment">#选择合适自己的镜像  R语言设置CRAN及bioconductor镜像 </span></span><br><span class="line"></span><br><span class="line">biocLite(c(<span class="string">'limma'</span>, <span class="string">'edgeR'</span>, <span class="string">'DESeq2'</span>, <span class="string">'clusterProfiler'</span>, <span class="string">'DOSE'</span>, <span class="string">'org.Hs.eg.db'</span>, <span class="string">'biomaRt'</span>, <span class="string">'BiocParallel'</span>, <span class="string">'GenomicDataCommons'</span>))  </span><br><span class="line">install.packages(c(<span class="string">'shiny'</span>, <span class="string">'jsonlite'</span>, <span class="string">'rjson'</span>, <span class="string">'survival'</span>, <span class="string">'survminer'</span>, <span class="string">'ggplot2'</span>, <span class="string">'gplots'</span>, <span class="string">'Hmisc'</span>, <span class="string">'DT'</span>, <span class="string">'matrixStats'</span>, <span class="string">'xml2'</span>))  </span><br><span class="line"></span><br><span class="line"> /*  然后下载源码并安装  */  </span><br><span class="line"></span><br><span class="line">wget https://github.com/Jialab-UCR/Jialab-UCR.github.io/blob/master/GDCRNATools_0.99.16.tar.gz   </span><br><span class="line">install.packages(<span class="string">'GDCRNATools_0.99.16.tar.gz'</span>, repos = NULL, <span class="built_in">type</span>=<span class="string">'source'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="bioconductor下载"><a href="#bioconductor下载" class="headerlink" title="bioconductor下载"></a>bioconductor下载</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span>(“https://bioconductor.org/biocLite.R”)</span><br><span class="line">biocLite(“GDCRNATools”)</span><br></pre></td></tr></table></figure>

<h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p><a href="http://bioconductor.org/packages/devel/bioc/vignettes/GDCRNATools/inst/doc/GDCRNATools.html" target="_blank" rel="noopener">介绍链接</a></p>
<h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><h3 id="下载TCGA-metadata数据"><a href="#下载TCGA-metadata数据" class="headerlink" title="下载TCGA metadata数据"></a>下载TCGA metadata数据</h3><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载TCGA-CHOL的RNAseq metadata数据</span></span><br><span class="line">metaMatrix.RNA &lt;- gdcParseMetadata(project.id = <span class="string">'TCGA-CHOL'</span>,</span><br><span class="line">                                   data.type  = <span class="string">'RNAseq'</span>, </span><br><span class="line">                                   write.meta = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对sample去重</span></span><br><span class="line">metaMatrix.RNA &lt;- gdcFilterDuplicate(metaMatrix.RNA)</span><br><span class="line"><span class="comment"># 对sample_type 只留下Primary Tumor 和 Solid Tissue Normal </span></span><br><span class="line">metaMatrix.RNA &lt;- gdcFilterSampleType(metaMatrix.RNA)</span><br><span class="line">datatable(as.data.frame(metaMatrix.RNA[<span class="number">1</span>:<span class="number">5</span>,]), extensions = <span class="string">'Scroller'</span>,</span><br><span class="line">        options = list(scrollX = <span class="literal">TRUE</span>, deferRender = <span class="literal">TRUE</span>, scroller = <span class="literal">TRUE</span>))</span><br></pre></td></tr></table></figure>

<p>这一步有可能非常慢，如果很慢或者报错就请用以下GDC API工具会快很多。（比如BRCA就会报错，用GDC API一分钟不到就下好了）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##### 首先下载TSV文件 #####</span><br><span class="line">curl --request POST --header &quot;Content-Type: application&#x2F;json&quot; --data @chol &#39;https:&#x2F;&#x2F;api.gdc.cancer.gov&#x2F;files&#39; &gt; res_chol.tsv</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100 46149  100 45228  100   921   4812     98  0:00:09  0:00:09 --:--:-- 11025</span><br><span class="line"></span><br><span class="line">&#x2F;* TCGA-CHOL的json文件内容 *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">	&quot;filters&quot;:&#123;</span><br><span class="line">		&quot;op&quot;:&quot;and&quot;,</span><br><span class="line">		&quot;content&quot;:[</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;op&quot;:&quot;in&quot;,</span><br><span class="line">				&quot;content&quot;:&#123;</span><br><span class="line">					&quot;field&quot;:&quot;cases.project.project_id&quot;,</span><br><span class="line">					&quot;value&quot;:[</span><br><span class="line">						&quot;TCGA-CHOL&quot;</span><br><span class="line">					]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				&quot;op&quot;:&quot;in&quot;,</span><br><span class="line">				&quot;content&quot;:&#123;</span><br><span class="line">					&quot;field&quot;:&quot;analysis.workflow_type&quot;,</span><br><span class="line">					&quot;value&quot;:&quot;HTSeq - Counts&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;format&quot;:&quot;tsv&quot;,</span><br><span class="line">	&quot;fields&quot;:&quot;file_name,file_id,cases.samples.submitter_id,associated_entities.entity_submitter_id,cases.samples.sample_type,cases.submitter_id,cases.demographic.gender,cases.project.project_id,cases.diagnoses.tumor_stage,cases.diagnoses.tumor_grade,cases.diagnoses.age_at_diagnosis,cases.diagnoses.days_to_death,cases.diagnoses.days_to_last_follow_up,cases.diagnoses.vital_status&quot;,</span><br><span class="line">	&quot;size&quot;:&quot;100000&quot;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 然后R语言读取TSV文件，格式处理下 #####</span><br><span class="line"></span><br><span class="line">&#x2F;* not convert factor *&#x2F;</span><br><span class="line">meta_brca&lt;-read.delim(&quot;res_brca.tsv&quot;,as.is&#x3D;TRUE)</span><br><span class="line">meta_brca&lt;-data.frame(file_name&#x3D;meta_brca$file_name,file_id&#x3D;meta_brca$file_id,patient&#x3D;meta_brca$cases.0.submitter_id,sample&#x3D;substr(meta_brca$cases.0.samples.0.submitter_id,1,nchar(as.character(meta_brca$cases.0.samples.0.submitter_id))-1),submitter_id&#x3D;meta_brca$cases.0.samples.0.submitter_id,entity_submitter_id&#x3D;meta_brca$associated_entities.0.entity_submitter_id,sample_type&#x3D;meta_brca$cases.0.samples.0.sample_type,gender&#x3D;meta_brca$cases.0.demographic.gender,age_at_diagnosis&#x3D;meta_brca$cases.0.diagnoses.0.age_at_diagnosis,tumor_stage&#x3D;meta_brca$cases.0.diagnoses.0.tumor_stage,tumor_grade&#x3D;meta_brca$cases.0.diagnoses.0.tumor_grade,days_to_death&#x3D;meta_brca$cases.0.diagnoses.0.days_to_death,days_to_last_follow_up&#x3D;meta_brca$cases.0.diagnoses.0.days_to_last_follow_up,vital_status&#x3D;meta_brca$cases.0.diagnoses.0.vital_status,project_id&#x3D;meta_brca$cases.0.project.project_id)</span><br><span class="line"></span><br><span class="line">rownames(meta_brca)&lt;-meta_brca$submitter_id</span><br><span class="line">&#x2F;* 对sample去重 *&#x2F;</span><br><span class="line">meta_brca&lt;- meta_brca[-which(duplicated(meta_brca$sample)),]</span><br><span class="line">&#x2F;* 对sample_type 只保留  Primary Tumor和 Solid Tissue Normal *&#x2F;</span><br><span class="line">meta_brca&lt;-meta_brca[which(meta_brca$sample_type %in% c(&quot;Primary Tumor&quot;, &quot;Solid Tissue Normal&quot;)),]</span><br><span class="line">##### 完成以上两步以后就跟gdcParseMetadata函数运行的结果差不多了 #####</span><br></pre></td></tr></table></figure>
<h2 id="下载miRNA表达量数据"><a href="#下载miRNA表达量数据" class="headerlink" title="下载miRNA表达量数据"></a>下载miRNA表达量数据</h2><p>只下载    Isoform Expression Quantification数据。因为这个数据包含isform基因组坐标。</p>
<h2 id="Isoform表达量数据处理"><a href="#Isoform表达量数据处理" class="headerlink" title="Isoform表达量数据处理"></a>Isoform表达量数据处理</h2><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fl：8039d5e4-8a8a-405b-b00b-049aa043654b.mirbase21.isoforms.quantification.txt  </span></span><br><span class="line">expr &lt;- read.table(fl, header=<span class="literal">TRUE</span>, stringsAsFactors = <span class="literal">FALSE</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选miRNA_region列以mature开头的数据  </span></span><br><span class="line">expr &lt;- expr[startsWith(expr$miRNA_region, <span class="string">"mature"</span>),]  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 以miRNA_region列分组，计算read_count列总和  </span></span><br><span class="line">expr &lt;- aggregate(expr$read_count, list(expr$miRNA_region), sum)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># strsplit生成list，lapply对list每个元素取第二个子元素并生成list，unlist将list转为character  </span></span><br><span class="line">mirs &lt;- unlist(lapply(strsplit(expr$Group.1, <span class="string">','</span>, fixed=<span class="literal">TRUE</span>)， <span class="keyword">function</span>(mir) mir[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>

<h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parser</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        parser: parses the tokens of the list 'tokens'</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">global</span> tokens  </span><br><span class="line">    <span class="keyword">global</span> eax,ebx,ecx,edx  </span><br><span class="line">    <span class="keyword">assert</span> len(tokens) &gt; <span class="number">0</span> , <span class="string">"no tokens"</span>  </span><br><span class="line">    pointer = <span class="number">0</span> <span class="comment"># pointer for tokens  </span></span><br><span class="line">    token = Token(<span class="string">""</span>,<span class="string">""</span>)  </span><br><span class="line">    tmpToken = Token(<span class="string">""</span>,<span class="string">""</span>)  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> pointer &lt; len(tokens):  </span><br><span class="line">        token = tokens[pointer]  </span><br><span class="line">        <span class="keyword">if</span> token.token == <span class="string">"mov"</span>:      <span class="comment"># mov commando  </span></span><br><span class="line">            <span class="comment"># it must follow a register  </span></span><br><span class="line">            <span class="keyword">if</span> pointer+<span class="number">1</span> &lt; len(tokens):  </span><br><span class="line">                pointer += <span class="number">1</span>  </span><br><span class="line">                token = tokens[pointer]  </span><br><span class="line">                </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                <span class="keyword">print</span> <span class="string">"Error: Not found argument!"</span>  </span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>RNA表达量分析</category>
      </categories>
      <tags>
        <tag>RNA表达量分析</tag>
      </tags>
  </entry>
  <entry>
    <title>ChIP-seq分析实例</title>
    <url>/2020/01/06/ChIP-seq/</url>
    <content><![CDATA[<p> 本例子选取的文章是为了探索PRC1，PCR2这样的蛋白复合物，不是转录因子或者组蛋白的CHIP-seq。</p>
<a id="more"></a>
<p><a href="https://mp.weixin.qq.com/s/_A0rHldzEgVk7bgwt457qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/_A0rHldzEgVk7bgwt457qQ</a>?<br><a href="https://www.ncbi.nlm.nih.gov/pubmed/23273917" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/pubmed/23273917</a></p>
<h3 id="sra数据下载"><a href="#sra数据下载" class="headerlink" title="sra数据下载"></a>sra数据下载</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/oAUPFQQ5EKRtUvC7EsmA5MXI2UnsOxrz4rwMjf7oDjosdVc5EzTecJlY5dIyuGOOClMlDpPq2FdlVHH1fhceEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="image"></p>
<p>在NCBI的FTP数据库找到SRP017311 </p>
<p><a href="ftp://ftp.ncbi.nlm.nih.gov/sra/sra-instant/reads/ByStudy/sra/SRP/SRP017/SRP017311/" target="_blank" rel="noopener">ftp://ftp.ncbi.nlm.nih.gov/sra/sra-instant/reads/ByStudy/sra/SRP/SRP017/SRP017311/</a></p>
<h4 id="下载sra文件"><a href="#下载sra文件" class="headerlink" title="下载sra文件"></a>下载sra文件</h4><p>使用wget下载，会较慢。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((i=4;i&lt;=9;i++)) ;do wget ftp://ftp-trace.ncbi.nlm.nih.gov/sra/sra-instant/reads/ByStudy/sra/SRP/SRP017/SRP017311/SRR62020$i/SRR62020$i.sra;done</span><br></pre></td></tr></table></figure>

<p>使用ascp下载，速度飞快。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for ((i=4;i&lt;=9;i++)) ;do ascp -T -l 200M -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh anonftp@ftp-private.ncbi.nlm.nih.gov:/sra/sra-instant/reads/ByStudy/sra/SRP/SRP017/SRP017311/SRR62020$i/SRR62020$i.sra ./;done</span><br></pre></td></tr></table></figure>

<h4 id="sra文件转化为fastq格式"><a href="#sra文件转化为fastq格式" class="headerlink" title="sra文件转化为fastq格式"></a>sra文件转化为fastq格式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls *sra |while read id; do ~/biosoft/sratoolkit/sratoolkit.2.6.3-centos_linux64/bin/fastq-dump –split-3 $id;done</span><br></pre></td></tr></table></figure>

<h3 id="Qualify-control"><a href="#Qualify-control" class="headerlink" title="Qualify control"></a>Qualify control</h3><p>使用的是fastqc软件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls *fastq |xargs ~/biosoft/fastqc/FastQC/fastqc -t 10</span><br></pre></td></tr></table></figure>


<h3 id="比对到参考基因组并sort-BAM"><a href="#比对到参考基因组并sort-BAM" class="headerlink" title="比对到参考基因组并sort BAM"></a>比对到参考基因组并sort BAM</h3><p>使用的软件是bowtie2比对，samtools排序。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~/biosoft/bowtie/bowtie2-2.2.9/bowtie2 -p 6 -3 5 --local -x ~/reference/index/bowtie/mm10 -U SRR620204.fastq| samtools sort -O bam -o ring1B.bam</span><br><span class="line"></span><br><span class="line">~/biosoft/bowtie/bowtie2-2.2.9/bowtie2 -p 6 -3 5 --local -x ~/reference/index/bowtie/mm10 -U SRR620205.fastq| samtools sort -O bam -o cbx7.bam</span><br><span class="line"></span><br><span class="line">~/biosoft/bowtie/bowtie2-2.2.9/bowtie2 -p 6 -3 5 --local -x ~/reference/index/bowtie/mm10 -U SRR620206.fastq| samtools sort -O bam -o suz12.bam</span><br><span class="line"></span><br><span class="line">~/biosoft/bowtie/bowtie2-2.2.9/bowtie2 -p 6 -3 5 --local -x ~/reference/index/bowtie/mm10 -U SRR620207.fastq| samtools sort -O bam -o RYBP.bam</span><br><span class="line"></span><br><span class="line">~/biosoft/bowtie/bowtie2-2.2.9/bowtie2 -p 6 -3 5 --local -x ~/reference/index/bowtie/mm10 -U SRR620208.fastq| samtools sort -O bam -o IgGold.bam</span><br><span class="line"></span><br><span class="line">~/biosoft/bowtie/bowtie2-2.2.9/bowtie2 -p 6 -3 5 --local -x ~/reference/index/bowtie/mm10 -U SRR620209.fastq| samtools sort -O bam -o IgG.bam</span><br></pre></td></tr></table></figure>

<h3 id="Peak-Calling"><a href="#Peak-Calling" class="headerlink" title="Peak Calling"></a>Peak Calling</h3><p>call peak使用的是macs2软件的callpeak方法。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">nohup ~/.local/bin/macs2 callpeak -c ../IgGold.bam -t ../suz12.bam -m 10 30 -p 1e-5 -f BAM -g mm -n suz12 2&gt;suz12.masc2.log &amp;</span><br><span class="line"></span><br><span class="line">nohup ~/.local/bin/macs2 callpeak -c ../IgGold.bam -t ../ring1B.bam -m 10 30 -p 1e-5 -f BAM -g mm -n ring1B 2&gt;ring1B.masc2.log &amp;</span><br><span class="line"></span><br><span class="line">nohup ~/.local/bin/macs2 callpeak -c ../IgG.bam -t ../cbx7.bam -m 10 30 -p 1e-5 -f BAM -g mm -n cbx7 2&gt;cbx7.masc2.log &amp;</span><br><span class="line"></span><br><span class="line">nohup ~/.local/bin/macs2 callpeak -c ../IgG.bam -t ../RYBP.bam -m 10 30 -p 1e-5 -f BAM -g mm -n RYBP 2&gt;RYBP.masc2.log &amp;</span><br></pre></td></tr></table></figure>
<p>相关参数如下：</p>
<ul>
<li>-c表示对照样本和-t表示处理样本。 其中-t必须，很好理解，没有处理组你还找啥Peak。</li>
<li>-m 构建双峰模型时使用，默认是[5,50]，表示选择那些倍数变化在5~10之间的富集区域。如果找不到100个区域构建模型，并且你还设置了–fix-bimodal时，它就会用–extsize参数继续分析。</li>
<li>-f 用来声明输入的文件格式。</li>
<li>-p：使用P值，而不是q值，也就是说用未多重矫正的p值进行筛选。</li>
<li>-n是随便取的，表示实验的名称，最好取个有意义的名字。</li>
<li>-g表示实际可比对的基因组大小。hs:    2.7e9。mm:    1.87e9。</li>
</ul>
]]></content>
      <categories>
        <category>ChIP-seq</category>
      </categories>
      <tags>
        <tag>ChIP-seq</tag>
      </tags>
  </entry>
  <entry>
    <title>文献获取的途径</title>
    <url>/2020/01/06/sci/</url>
    <content><![CDATA[<h3 id="Science-Hub-或Library-Genesis"><a href="#Science-Hub-或Library-Genesis" class="headerlink" title="Science Hub 或Library Genesis"></a>Science Hub 或Library Genesis</h3><p>sci-hub的域名经常切换，所以如果一个域名失效了可以试试sci-hub.tw、sci-hub.la、sci-hub.bz、sci-hub.io等。<br>而libgen的域名一直未变：<a href="http://gen.lib.rus.ec/，也可以通过libgen找到最新的sci-hub网址。" target="_blank" rel="noopener">http://gen.lib.rus.ec/，也可以通过libgen找到最新的sci-hub网址。</a></p>
<a id="more"></a>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzUzODg0ODA4MA==&amp;mid=2247483906&amp;idx=1&amp;sn=619dbe03be5dd99ddfaf018e8e76ee67&amp;chksm=fad03c3dcda7b52b0b99d6f7f6aa58d983cfa0ed96136ec4e9c5ca6a5542a8b9ccb712ceb2e3&amp;mpshare=1&amp;scene=1&amp;srcid=0818qkVvfuxagvvfe6tRx0WT#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzUzODg0ODA4MA==&amp;mid=2247483906&amp;idx=1&amp;sn=619dbe03be5dd99ddfaf018e8e76ee67&amp;chksm=fad03c3dcda7b52b0b99d6f7f6aa58d983cfa0ed96136ec4e9c5ca6a5542a8b9ccb712ceb2e3&amp;mpshare=1&amp;scene=1&amp;srcid=0818qkVvfuxagvvfe6tRx0WT#rd</a></p>
<h3 id="Glgoo学术搜索"><a href="#Glgoo学术搜索" class="headerlink" title="Glgoo学术搜索"></a>Glgoo学术搜索</h3><p><a href="https://xue.glgoo.org/" target="_blank" rel="noopener">https://xue.glgoo.org/</a></p>
<h3 id="谷粉学术"><a href="#谷粉学术" class="headerlink" title="谷粉学术"></a>谷粉学术</h3><p><a href="https://gfsoso.99lb.net/" target="_blank" rel="noopener">https://gfsoso.99lb.net/</a></p>
<h3 id="PubMed文献检索"><a href="#PubMed文献检索" class="headerlink" title="PubMed文献检索"></a>PubMed文献检索</h3><p><a href="http://www.ncbi.nlm.nih.gov/PubMed/" target="_blank" rel="noopener">http://www.ncbi.nlm.nih.gov/PubMed/</a></p>
<p>遇到下载不了的文献，也可以关注“生物学霸”，输入P+PMID可以获取文献，每天有3次机会。</p>
]]></content>
      <categories>
        <category>文献下载</category>
      </categories>
      <tags>
        <tag>文献下载</tag>
      </tags>
  </entry>
  <entry>
    <title>1000genomes</title>
    <url>/2020/01/06/1000genomes/</url>
    <content><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>2008年至2015年，现在已经结束。之后由EMBL-EBI存储以及后期扩大。4x的测序深度，虽然不能发现所有的变体，但是能发现1%频率的变体。</p>
<p>2010年6月21日，由中国深圳华大基因研究院、英国桑格研究所和美国国立人类基因组研究所等共同发起并主导的“国际千人基因组计划”协作组对外宣布：该计划第一阶段的“3个先导项目”已圆满完成，全部数据已存储于该计划所设立的公共数据库，公众可免费获取和浏览第一阶段产生的全部数据 。这就是现在的<a href="http://www.internationalgenome.org/about" target="_blank" rel="noopener">1000genomes</a>数据库。</p>
<a id="more"></a>
<ul>
<li><p>第一个先导项目运用多种下一代高通量测序技术平台，完成了两个核心家庭共6人的高覆盖度全基因组测序，每个基因组的测序深度在20～60倍。通过此项目，可以评价多种主要测序方法的优缺点，为“国际千人基因组计划”的后续项目扫清技术障碍。</p>
</li>
<li><p>第二个先导项目完成了179人的低覆盖度全基因组测序，平均测序深度在3倍。数据表明，大样本低覆盖度测序在降低成本的同时，仍然能有效识别人群中的基因多样性。</p>
</li>
<li><p>第三个先导项目通过对700人的1000个基因外显子的测序，获得了占人类基因组全部序列2%的蛋白质编码基因名录。前所未有的大样本量有助于研究人群罕见变异的表达图谱。</p>
</li>
</ul>
<p>该数据库最终将包含来自全球27个族群的2500个人的全部基因组信息。目前产生的数据量已达到50TB（5万GB），包含8万亿个DNA碱基对。这一数据资源是一个开放的公共资源，为各种疾病的关联分析提供详细的基础数据；为解释人类重大疾病发病机理、开展个性化预测、预防和治疗打下基础。此外，该项目还加深了人们对人类群体遗传学的理解，促进人类进化史的研究。目前已完成的3个先导项目是为了验证多种测序方法对于东亚、欧洲和非洲人群中遗传多态性频率不低于1%的鉴别能力，这将大大高于之前完成的国际单倍体型计划（HapMap计划）5%～10%的遗传多态性的检出能力。</p>
<h3 id="下载某基因的vc文件"><a href="#下载某基因的vc文件" class="headerlink" title="下载某基因的vc文件"></a>下载某基因的vc文件</h3><p><a href="https://mp.weixin.qq.com/s/n0lHCcOqp1kWbuyFjb7IJw" target="_blank" rel="noopener">教程链接</a></p>
<h3 id="ftp下载"><a href="#ftp下载" class="headerlink" title="ftp下载"></a>ftp下载</h3><p>FTP 结构(README.ftp_structure) 千人基因组计划有两个主要的 ftp 站点镜像：</p>
<ul>
<li><a href="ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/" target="_blank" rel="noopener">ftp://ftp.1000genomes.ebi.ac.uk/vol1/ftp/</a></li>
<li><a href="ftp://ftp-trace.ncbi.nih.gov/1000genomes/ftp/" target="_blank" rel="noopener">ftp://ftp-trace.ncbi.nih.gov/1000genomes/ftp/</a></li>
</ul>
<h4 id="FTP下一些文件夹的意思如下："><a href="#FTP下一些文件夹的意思如下：" class="headerlink" title="FTP下一些文件夹的意思如下："></a>FTP下一些文件夹的意思如下：</h4><ul>
<li>data：data 目录包含主要工程的每个个体的子目录， 每个单独的子目录也包含一系列 的子目录–包含不同的数据集，例如 sequence reads 和 sequence alignments 等。 individual id 或 coriell sample names /technical/working/20140502_ sample_ summary_ info/以及/technical/working/20130606_ sample_ info/中有 individual id 与 population 对应的信息。</li>
</ul>
]]></content>
      <categories>
        <category>二代测序</category>
      </categories>
      <tags>
        <tag>二代测序</tag>
        <tag>基因组</tag>
      </tags>
  </entry>
  <entry>
    <title>高通量测序名词解释</title>
    <url>/2020/01/06/ngs/</url>
    <content><![CDATA[<h4 id="全基因组重测序"><a href="#全基因组重测序" class="headerlink" title="全基因组重测序"></a>全基因组重测序</h4><p>是重新测序的意思么?也对，因为基因组序列已知啦，但是由于个体的不同就有了差异性，所以需要对不同的个体进行测序哦，并且在此的基础上，对个体或者群体的差异性进行分析。全基因组重测序的个体，通过序列比对，可以找到大量的单核苷酸多态性位点（SNP），插入缺失位点（InDel，Insertion/Deletion）、结构变异位点（SV，Structure Variation）位点和拷贝数变异位点（CNV，copy number variation)。然后经过注释，就能得到很多很多有用的信息，具有辣么辣么大（比我的脸大很多）的科研和产业价值。她的英文名叫英文名为Genome Re-sequencing哦。</p>
<a id="more"></a>
<h4 id="de-novo测序"><a href="#de-novo测序" class="headerlink" title="de novo测序"></a>de novo测序</h4><p> 一看，就不是英语。一查，原来是拉丁文。也叫从头测序（这多好，通俗易懂。）牛逼的是不要任何现有的序列资料就可以对某个物种进行测序，通过生物信息学分析手段对序列进行拼接，组装，就可以获得该物种的基因图谱了。嗷~~厉害了。所以我们一猜他就是应用于从头解析未知物种的基因组序列、基因组成、进化特点等</p>
<h4 id="外显子测序"><a href="#外显子测序" class="headerlink" title="外显子测序"></a>外显子测序</h4><p>顾名思义，它就是通过序列捕获技术将全基因组外显子区域DNA捕捉并富集后进行高通量测序的基因组分析方法。因为外显子相对少啊，所以成本低啊，对研究已知基因的SNP、Indel等具有较大的优势，但无法研究基因组结构变异如染色体断裂重组等。一会儿我告诉你啥叫SNP、Indel、基因组结构变异噻。</p>
<h4 id="mRNA测序-（RNA-seq）"><a href="#mRNA测序-（RNA-seq）" class="headerlink" title="mRNA测序 （RNA-seq）"></a>mRNA测序 （RNA-seq）</h4><p>转录组测序技术，就是把mRNA,smallRNA,and NONcoding RNA等或者其中一些用高通量测序技术把它们的序列测出来。反映出它们的表达水平。</p>
<p>Illumina公司提供的mRNA测序技术可在整个mRNA领域进行各种相关研究和新的发现。mRNA测序不对引物或探针进行设计，可自由提供关于转录的客观和权威信息。</p>
<p>研究人员仅需要一次试验即可快速生成完整的poly-A尾的RNA完整序列信息，并分析基因表达、cSNP、全新的转录、全新异构体、剪接位点、等位基因特异性表达和罕见转录等最全面的转录组信息。简单的样品制备和数据分析软件支持在所有物种中的mRNA测序研究</p>
<h4 id="small-RNA测序"><a href="#small-RNA测序" class="headerlink" title="small RNA测序"></a>small RNA测序</h4><p>从前有三个人micro RNAs、siRNAs和 pi RNAs，他们都叫Small RNA（和谐创造美好未来，三人用一名儿也是很可以），他们是生命活动重要的调控因子，在基因表达调控、生物个体发育、代谢及疾病的发生等生理过程中起着重要的作用。</p>
<p>Illumina能够对细胞或者组织中的全部Small RNA进行深度测序及定量分析等研究。</p>
<p>实验时首先将18-30 nt范围的Small RNA从总RNA中分离出来，两端分别加上特定接头后体外反转录做成cDNA再做进一步处理后，利用测序仪对DNA片段进行单向末端直接测序。通过Illumina对Small RNA大规模测序分析，可以从中获得物种全基因组水平的miRNA图谱，实现包括新miRNA分子的挖掘，其作用靶基因的预测和鉴定、样品间差异表达分析、miRNAs聚类和表达谱分析等科学应用。 </p>
<h4 id="ATAC-seq"><a href="#ATAC-seq" class="headerlink" title="ATAC-seq"></a>ATAC-seq</h4><p>Assay for Transposase Accessible Chromatin using sequencing，简称ATAC-seq。即运用测序手段研究转座酶可接近的染色质区域的实验。关键词：测序，转座酶可接近染色质，转座酶能接近的区域，也就是处于开放状态的区域，这也是本实验的关键所在，测序和染色质开放区域。</p>
<p>核小体连接致密的地方，转座酶不能进入，而松散的区域，转座酶能够进入并切割下暴露的DNA并同时连接上特异性的adapters，连接上adapters的DNA片段被分离出来，用于二代测序。因此，ATAC-seq得到的，是全基因度尺度上处于开放状态的染色质区域。</p>
<p>获得了开放区域能干啥，预测上面结合的转录因子啊！</p>
<p>ATAC-seq概念来自于<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3959825/" target="_blank" rel="noopener">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3959825/</a></p>
<h4 id="Chip-seq"><a href="#Chip-seq" class="headerlink" title="Chip-seq"></a>Chip-seq</h4><blockquote>
<p>染色质免疫共沉淀技术（ChromatinImmunoprecipitation，ChIP）也称结合位点分析法，是研究体内蛋白质与DNA相互作用的有力工具，通常用于转录因子结合位点或组蛋白特异性修饰位点的研究。</p>
</blockquote>
<p>将ChIP与第二代测序技术相结合的ChIP-Seq技术，能够高效地在全基因组范围内检测与组蛋白、转录因子等互作的DNA区段。</p>
<p>原理如→：首先通过染色质免疫共沉淀技术（ChIP）特异性地富集目的蛋白结合的DNA片段，并对其进行纯化与文库构建；</p>
<p>然后对富集得到的DNA片段进行高通量测序。研究人员通过将获得的数百万条序列标签精确定位到基因组上，</p>
<p>从而获得全基因组范围内与组蛋白、转录因子等互作的DNA区段信息。</p>
<p>能干下面这些事：</p>
<p>（1）判断DNA链的某一特定位置会出现何种组蛋白修饰；</p>
<p>（2）检测RNA polymerase II及其它反式因子在基因组上结合位点的精确定位；</p>
<p>（3）研究组蛋白共价修饰与基因表达的关系；</p>
<p>（4）CTCF转录因子研究。</p>
<p>ATAC-Seq与ChIP-Seq的不同的是ATAC-Seq是全基因组范围内检测染色质的开放程度，可以得到全基因组范围内的蛋白质可能结合的位点信息，一般用于不知道特定的转录因子，用此方法与其他方法结合筛查感兴趣的特定调控因子；但是ChIP-Seq是明确知道感兴趣的转录因子是什么，根据感兴趣的转录因子设计抗体去做ChIP实验拉DNA，验证感兴趣的转录因子是否与DNA存在相互作用。</p>
<h4 id="RIP-seq"><a href="#RIP-seq" class="headerlink" title="RIP-seq"></a>RIP-seq</h4><p>RNA Immunoprecipitation，是研究细胞内RNA与蛋白结合情况的技术，是了解转录后调控网络动态过程的有力工具，能帮助我们发现miRNA的调节靶点。</p>
<p>这种技术运用针对目标蛋白的抗体把相应的RNA-蛋白复合物沉淀下来，然后经过分离纯化就可以对结合在复合物上的RNA进行测序分析。 </p>
<p>它对象（研究对象，不是女朋友！）是RNA-蛋白复合物不是DNA-蛋白复合物。</p>
<p>RIP实验的优化条件与ChIP实验不太相同（如复合物不需要固定，RIP反应体系中的试剂和抗体绝对不能含有RNA酶，抗体需经RIP实验验证等等）。RIP技术下游结合microarray技术被称为RIP-Chip，</p>
<p>帮助我们更高通量地了解癌症以及其它疾病整体水平的RNA变化。</p>
<h4 id="metagenomic（宏基因组）"><a href="#metagenomic（宏基因组）" class="headerlink" title="metagenomic（宏基因组）"></a>metagenomic（宏基因组）</h4><blockquote>
<p>听起来很大，结果研究的对象是整个微生物群落。相对于传统单个细菌研究来说，他有两个牛逼的优点：(1) 微生物通常是以群落方式共生于某一小生境中，它们的很多特性是基于整个群落环境及个体间的相互影响的，因此做Metagenomics研究比做单个个体的研究更能发现其特性；<br>(2) Metagenomics研究不需要！不需要！不需要分离单个细菌，所以可以研究那些不能被实验室分离培养的微生物。</p>
</blockquote>
<p>下面念经模式：</p>
<p>宏基因组是基因组学一个新兴的科学研究方向。宏基因组学（又称元基因组学，环境基因组学，生态基因组学等），是研究直接从环境样本中提取的基因组遗传物质的学科。传统的微生物研究依赖于实验室培养，元基因组的兴起填补了无法在传统实验室中培养的微生物研究的空白。过去几年中，DNA测序技术的进步以及测序通量和分析方法的改进使得人们得以一窥这一未知的基因组科学领域。</p>
<h4 id="Segment-duplication"><a href="#Segment-duplication" class="headerlink" title="Segment duplication"></a>Segment duplication</h4><blockquote>
<p>串联重复！<br>一般称为SD区域，串联重复是由序列相近的一些DNA片段串联组成。<br>串联重复在人类基因多样性的灵长类基因中发挥重要作用。<br>在人类染色体Y和22号染色体上，有很大的SD序列。</p>
</blockquote>
<h4 id="soft-clipped-reads"><a href="#soft-clipped-reads" class="headerlink" title="soft-clipped reads"></a>soft-clipped reads</h4><blockquote>
<p>因为他对鉴定染色体结构变异及外源序列整合具有重要作用。所以我们要晓得它，当基因组发生某一段的缺失，或转录组的剪接，<br>在测序过程中，横跨缺失位点及剪接位点的reads回帖到基因组时，一条reads被切成两段，匹配到不同的区域，<br>这样的reads叫做soft-clipped reads</p>
</blockquote>
<h4 id="multi-hits-reads"><a href="#multi-hits-reads" class="headerlink" title="multi-hits reads"></a>multi-hits reads</h4><blockquote>
<p>multi-hits reads 是有多个匹配位置的reads.由于大部分测序得到的reads较短，一个reads能够匹配到基因组多个位置，无法区分其真实来源的位置。</p>
</blockquote>
<p>一些工具根据统计模型，如将这类reads分配给reads较多的区域</p>
<h4 id="Contig-amp-Contig-N50"><a href="#Contig-amp-Contig-N50" class="headerlink" title="Contig &amp; Contig N50"></a>Contig &amp; Contig N50</h4><p>1.拼接软件基于reads之间的overlap区，拼接获得的序列称为Contig（重叠群）。</p>
<p>2.Reads拼接后会获得一些不同长度的Contigs。将所有的Contig长度相加，能获得一个Contig总长度。然后将所有的Contigs按照从长到短进行排序，如获得Contig 1，Contig 2，Contig 3…………Contig 25。将Contig按照这个顺序依次相加，当相加的长度达到Contig总长度的一半时，最后一个加上的Contig长度即为Contig N50。举例：Contig 1+Contig 2+ Contig 3+Contig 4=Contig总长度x1/2时，Contig 4的长度即为Contig N50。Contig N50可以作为基因组拼接的结果好坏的一个判断标准。 </p>
<p>总而言之：</p>
<p>1.Contig就是reads之间的重叠区拼接获得的序列！</p>
<p>2.就是将不同长度的Contig从长到短排序，一次相加，加到总长的1/2时的Contig就是Contig N50。</p>
<h4 id="Scaffold-amp-Scaffold-N50"><a href="#Scaffold-amp-Scaffold-N50" class="headerlink" title="Scaffold &amp; Scaffold N50"></a>Scaffold &amp; Scaffold N50</h4><p>1.基因组de novo测序，通过reads拼接获得Contigs后，</p>
<p>往往还需要构建454 Paired-end库或Illumina Mate-pair库，以获得一定大小片段（如3Kb、6Kb、10Kb、20Kb）两端的序列。基于这些序列，可以确定一些Contig之间的顺序关系，这些先后顺序已知的Contigs组成Scaffold。</p>
<p>就是知道顺序的Contigs组成Scaffold！！</p>
<h4 id="测序深度和覆盖度"><a href="#测序深度和覆盖度" class="headerlink" title="测序深度和覆盖度"></a>测序深度和覆盖度</h4><p> 1.测序深度是指测序得到的 总碱基数/待测基因组。</p>
<p>假设一个基因大小为2M，测序深度为10X，那么获得的总数据量为20M。</p>
<p>2.覆盖度是 测序获得的序列/整个基因组。</p>
<p>由于基因组中的高GC、重复序列等复杂结构的存在，测序最终拼接组装获得的序列往往无法覆盖有所的区域，这部分没有获得的区域就称为Gap。例如一个细菌基因组测序，覆盖度是98%，那么还有2%的序列区域是没有通过测序获得的。</p>
<h4 id="RPKM、FPKM"><a href="#RPKM、FPKM" class="headerlink" title="RPKM、FPKM"></a>RPKM、FPKM</h4><ul>
<li>RPKM：每1百万个map上的reads中map到外显子的每1K个碱基上的reads个数。 假如有1百万个reads映射到了人的基因组上，那么具体到每个外显子呢，有多少映射上了呢，而外显子的长度不一，那么每1K个碱基上又有多少reads映射上了呢，这大概就是这个RPKM的直观解释。</li>
<li>FPKM(fragments per kilobase of exon per million fragments mapped). FPKM与RPKM计算方法基本一致。不同点就是FPKM计算的是fragments，而RPKM计算的是reads。Fragment比read的含义更广，因此FPKM包含的意义也更广，可以是pair-end的一个fragment，也可以是一个read。<br>如果对应特定基因的话，那么就是每1000000 mapped到该基因上的reads中每kb有多少是mapped到该基因上的exon的read</li>
</ul>
<ul>
<li>Total exon reads: 映射到外显子上 总的reads个数。这个是映射到某个区域上的reads个数，这个区域或者是已知注释的基因或者跨两个外显子的边界或者是某个基因已经注释的转录本的内含子、外显子。对于真核生物来说，外显子和它们自己内部的关系由某类型的mRNA来注释。</li>
</ul>
<ul>
<li>Exon length: ==外显子的长度==。计算时，计算所有某个基因已注释的所有外显子长度的总和。即使某个基因以多种注释的转录本呈现，这个外显子在求和时只被包含一次。即使部分重叠的外显子共享相同的区域，重叠的外显子以其总长来计算。</li>
</ul>
<ul>
<li><p>Mapped reads:  map的reads总和。映射到某个基因上的所有reads总数。因此这包含所有的唯一映射到这个区域上的reads。</p>
<p> 举例：比如对应到该基因的read有1000个，总reads个数有100万，而该基因的外显子总长为5kb，那么它的RPKM为：10^9x1000(reads个数)/10^6(总reads个数)x5000(外显子长度)=200或者：1000(reads个数)/1(百万)x5(K)=200这个值反映基因的表达水平。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>高通量测序</category>
      </categories>
      <tags>
        <tag>高通量测序</tag>
      </tags>
  </entry>
  <entry>
    <title>单细胞测序了解了解</title>
    <url>/2020/01/02/singlecell/</url>
    <content><![CDATA[<h3 id="单细胞测序的发展史"><a href="#单细胞测序的发展史" class="headerlink" title="单细胞测序的发展史"></a>单细胞测序的发展史</h3><h3 id="为什么非要使用单细胞测序"><a href="#为什么非要使用单细胞测序" class="headerlink" title="为什么非要使用单细胞测序"></a>为什么非要使用单细胞测序</h3><p>从发育学的角度看，个体由受精卵分裂成胚囊，胚囊逐渐分化形成形态结构、功能特征各不相同的细胞类群，如神经系统、骨骼肌和生殖系统等等。不同组织结构，细胞之间有不同的遗传信息。</p>
<p>又比如在肿瘤组织中，肿块中心的细胞，肿块周围的细胞，淋巴转移灶的细胞，以及远端转移的细胞，其基因组和转录组等遗传信息，也是存在差异的。而这种差异，在临床上，可以决定该肿瘤对某种疗法是否有效。</p>
<p>另外,自然界中存在大量的难以培养富集的微生物,例如在人体中,90% 以上的微生物都是不能进行体外培养的。由于细胞数目有限,这些微生物的序列信息则很难通过传统高通量测序获得。</p>
<p>与传统的全基因组测序相比，单细胞测序不仅测量基因表达水平更加精确，而且还能检测到微量的基因表达子或罕见非编码RNA。</p>
<a id="more"></a>
<h3 id="一、单细胞测序的概念"><a href="#一、单细胞测序的概念" class="headerlink" title="一、单细胞测序的概念"></a>一、单细胞测序的概念</h3><p>单细胞测序是以单个细胞为单位通过全基因组或转录组扩增进行高通量测序，能够揭示单个细胞的基因结构和基因表达状态，反映细胞间的异质性。其在肿瘤、发育生物学、神经科学等领域有重要应用。</p>
<h3 id="二、单细胞测序的应用"><a href="#二、单细胞测序的应用" class="headerlink" title="二、单细胞测序的应用"></a>二、单细胞测序的应用</h3><ul>
<li>很重要的一个应用就是肿瘤的研究了；</li>
<li>在微生物多样性研究中的应用；</li>
<li>在神经科学研究中的应用；</li>
<li>在免疫学领域中应用；</li>
</ul>
<h3 id="三、单细胞测序的难点"><a href="#三、单细胞测序的难点" class="headerlink" title="三、单细胞测序的难点"></a>三、单细胞测序的难点</h3><p>传统的测序，需要从大量细胞中获取足够多的DNA才可以测序。而单个细胞的DNA简直是微乎其微，根本达不到测序的要求。并且，单个细胞怎么从组织中分离出来也是问题。分离出来的单细胞核苷酸扩增也是问题。</p>
<h4 id="1、单细胞分离"><a href="#1、单细胞分离" class="headerlink" title="1、单细胞分离"></a>1、单细胞分离</h4><p>目前常用的单细胞分离方法有连续稀释法、显微操作法、激光捕获显微切割术( laser capture microdissection,LCM)、拉曼镊子技术( Raman tweezers)、荧光激活细胞分选术( fluorescence activated cell sorting,FACS)和微流控技术( microfluidics)等。</p>
<ul>
<li><p>连续稀释法：操作简单、成本低廉,主要通过连续稀释样品来获取单个细胞。其缺点在于,容易出现分离错误或细胞丢失,不能进行靶向分离。因此,该技术很少用于复杂微生物样品的单细胞分离。</p>
</li>
<li><p>显微操作法：是借助机械显微操纵仪或可视化镊子分离单个细胞。这种方法不仅操作简单、成本低廉,而且能够进行可视化操作,目前已经应用到许多难以培养微生物的单细胞分离中,例如从白蚁肠道中分离共生体,从水稻土壤中分离苍白杆菌( Ochrobactrum)等。显微操作法虽然实现了可视化分离,但是人力投入大和通量较低等不足限制了该技术的广泛应用;另外,该技术还会对细胞造成机械性损伤。</p>
</li>
<li><p>激光捕获显微切割术( LCM)：能够直接从组织块中分离单个细胞,广泛应用于临床研究中。该技术首先将组织进行切片、装片和染色处理,进而通过可视化操作分离单细胞。其优势在于,能够保持细胞的形态学结构,保留细胞在组织中的空间位置信息。但是其劣势在于,细胞核容易被刨切而导致染色体片段丢失;另外,该技术由于精确度有限,切割过程中会不可避免的掺入相邻细胞的原生质组分,因此不适用于转录组学分析。</p>
</li>
<li><p>拉曼镊子技术：结合了拉曼显微光谱学和光学捕获技术,前者能够通过轮廓区分细胞而无需染色,后者利用激光捕获细胞。但这种方法仅限于分析形态学差异较大的细胞群。</p>
</li>
</ul>
<p>目前单个肿瘤细胞分离通常是通过磁珠激活细胞分选(magnetic-activated cell sorting,MACS)或荧光激活细胞分选(fluorescence-activated cell sorting,FACS)技术进行。这两种分离方法的成本较高,但是能满足高通量、自动化的要求。免疫磁珠分离法(immunomagnetic separation,IMS)属于MACS技术,即利用细胞表面抗原能与连接有磁珠的特异性单抗相结合。在外加磁场中,与磁珠相连的带有表面抗原的细胞被吸附而滞留在磁场中,不能与磁珠连接的细胞不在磁场中停留,从而使目的细胞得以快速分离,但操作方法相对复杂。</p>
<ul>
<li>荧光激活细胞分选技术：是目前应用最多的单细胞分离方法,可对单个细胞进行高效和快速分离。FACS平台通过依靠荧光标记信号结合光散射分析参数,对具有异质性的肿瘤组织的单个细胞进行挑选和分析。该法不仅具备高通量的优势,而且可对具有不同表征(如大小、粒度、特异性抗原标记、同位素标记等)的靶细胞进行识别和分离。其最大的缺陷是分选时需要大量的细胞,因此在制备大量细胞悬液的过程中可能降低低丰度细胞的获取率;同时FACS所检测的荧光信号相对较低,部分低表达的标记可能检测困难,存在特定细胞类型丢失的风险;此外,细胞的高速流动可能造成机械性损伤。</li>
<li>微流控技术(microfluidics)：是一种新发展的技术，是通过人为控制流体流动来实现在微尺度上对目的细胞进行分离,主要利用流控通道具备的多种功能对细胞进行分选,如通道本身具有可调节的直径(10-100μm)和多种功能性修饰(如捕获分子、抗体、电极等)。同时微流控装置的细胞污染率低,对样本和试剂损耗少,并且在降低单细胞测序的噪声以及提高基因组扩增一致性方面具有优势,已有相应的商业化平台在推广应用。</li>
</ul>
<h4 id="2、溶解细胞获取基因组DNA"><a href="#2、溶解细胞获取基因组DNA" class="headerlink" title="2、溶解细胞获取基因组DNA"></a>2、溶解细胞获取基因组DNA</h4><p>分离得到单细胞后,需要将细胞进行溶解来获取基因组DNA( genome DNA,g DNA)。这一步骤非常关键,g DNA的质量直接影响后续基因组扩增的效果。目前细胞溶解的方法可以分为3大类:物理法( 如超声、冷冻、研磨、剪切、高压和热破坏法)、化学法( 如SDS、triton X-100和极端pH)和酶降解法( 如蛋白酶K和溶菌酶)。细胞溶解方法的选定,需要综合考虑多方面因素,如细胞的类型、下游用途、g DNA纯化难易程度等。</p>
<p>在传统高通量测序流程中,细胞溶解获得的g DNA需要通过进一步纯化后才能用于扩增。但是对于单细胞测序,为了避免g DNA在纯化过程中丢失,目前大部分流程已经省去了这一步骤。在某些基因组中,各位点仅存在1个拷贝,纯化过程中的样品丢失会直接导致扩增产物中的位点缺失,严重影响后续的基因组重建。g DNA纯化步骤的省略,对细胞溶解操作提出了更加苛刻的要求,那些可能与基因组扩增试剂相互作用的溶解试剂都应当避免使用。另外,DNA结合蛋白通常会阻碍模板扩增,需要事先将其切割或变性;蛋白酶(如蛋白酶K和胰蛋白酶)可以高效地溶解DNA结合蛋白,目前广泛用于待扩增模板的预处理中。</p>
<h4 id="3、核苷酸扩增"><a href="#3、核苷酸扩增" class="headerlink" title="3、核苷酸扩增"></a>3、核苷酸扩增</h4><p>高通量测序至少需要200 ng的DNA样品,而1个细胞中的总DNA一般仅有数匹克,即使使用第3代测序技术可能也无法满足样品量的需求,因此WGA对于单细胞测序是非常必要的。全基因组扩增技术主要分为两种类型：一是基于热循环以PCR为基础的扩增技术，如简并寡核苷酸引物PCR (DOP-PCR)、连接反应介导的PCR (LM-PCR)、扩增前引物延伸反应(PEP)等；一是基于等温反应不以PCR为基础的扩增技术，如多重置换扩增(MDA)和基于引物酶的全基因组扩增(pWGA)。<br>在这两种类型中，PCR扩增比较经典，但是，对不同的序列来说，PCR扩增的效率存在相当大的偏差，易产生扩增偏倚问题：如富含CG的DNA序列和相应基因座位的非随机丢失，等位基因的非随机丢失，以及与DNA片段大小相关的偏差（倾向于扩增更多短片段），尤其是在应用于单细胞时，大量短片段导致片段间序列丢失，从而使其应用受限。<br>MDA是目前公认的最好的单细胞基因组扩增技术，它能对全基因组进行高保真的均匀扩增，扩增出10-100kb大小的片段，能提供大量均一完整的全基因组序列。但是MDA也有一些缺点，特别是显著的非特异扩增。另外就是全基因组覆盖度不均匀;等位基因丢失率高(可高达65%);污染或干扰;随机引物与模板结合能力差异导致的扩增偏倚。针对MDA潜在的污染问题(包括外源性或交叉污染),目前主要采取的改进措施是将荧光标记(例如SYBR Green)掺入反应体系中,以便对扩增过程进行可视化的荧光监测。该技术已成功应用于肿瘤单细胞测序;另一项极具创新性的技术MALBAC是由哈佛大学谢晓亮团队研发。与以前的技术相比,MALBAC的最大优势是采用线性扩增方式。其核心技术在于通过五轮MDA预扩增得到完整扩增产物;增加退火步骤达到链内杂交自我锁定,形成闭合的环状分子,避免指数扩增;再通过常规PCR进行扩增。由于此时的模板更加均一,则可达到低偏倚的目的。</p>
<h3 id="四、单细胞测序分类"><a href="#四、单细胞测序分类" class="headerlink" title="四、单细胞测序分类"></a>四、单细胞测序分类</h3><p>单细胞测序主要包括单细胞基因组测序、转录组测序和表观遗传测序,这3种测序类型各具特点和优势,可以从不同角度揭示细胞各个阶段的功能和特性。</p>
<h4 id="单细胞转录组测序RNA-seq"><a href="#单细胞转录组测序RNA-seq" class="headerlink" title="单细胞转录组测序RNA-seq"></a>单细胞转录组测序RNA-seq</h4><p>转录组测序则是获取特定器官或组织在某一状态下的几乎所有转录本,尤其适用于具有高度异质性的干细胞及胚胎发育早期的细胞群体的研究。</p>
<h4 id="单细胞全基因组测序DNA-seq"><a href="#单细胞全基因组测序DNA-seq" class="headerlink" title="单细胞全基因组测序DNA-seq"></a>单细胞全基因组测序DNA-seq</h4><p>全基因组测序是对目的细胞的全部基因组序列进行非选择性、均匀扩增,随后利用外显子捕获技术进而使用高通量测序的过程。</p>
]]></content>
      <categories>
        <category>单细胞测序</category>
      </categories>
      <tags>
        <tag>二代测序</tag>
        <tag>高通量测序</tag>
        <tag>单细胞测序</tag>
      </tags>
  </entry>
  <entry>
    <title>文本处理工具sed</title>
    <url>/2019/12/31/sed/</url>
    <content><![CDATA[<p>sed（stream editor）是一种非交互式的流编辑器，通过多种转换修改流经它的文本。但是请注意，默认情况下，sed并不会改变原文件本身，而只是对流经sed命令的文本进行修改，并将修改后的结果打印到标准输出中（也就是屏幕）。所以本节讲的所有的sed操作都只是对“流”的操作，并不会改变原文件。sed处理文本时是以行为单位的，每处理完一行就立即打印出来，然后再处理下一行，直至全文处理结束。sed可做的编辑动作包括删除、查找替换、添加、插入、从其他文件中读入数据等。</p>
<a id="more"></a>

<p>sed命令使用的场景包括以下一些：</p>
<ul>
<li>常规编辑器编辑困难的文本。</li>
<li>太过于庞大的文本，使用常规编辑器难以胜任（比如说vi一个几百兆的文件）。</li>
<li>有规律的文本修改，加快文本处理速度（比如说全文替换）。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [options] <span class="string">'command'</span> file</span><br><span class="line"><span class="comment">#options是sed可以接受的参数</span></span><br><span class="line"><span class="comment">#command是sed的命令集（一共有25个）</span></span><br><span class="line"><span class="comment">#使用-e参数和分号连接多编辑命令</span></span><br><span class="line"><span class="comment">#该参数本身只是sed的一个简单参数，表示将下一个字符串解析为sed编辑命令</span></span><br><span class="line"><span class="comment">#一般情况下可以忽略，但是当sed需要传递多个编辑命令时该参数就不能少了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#准备测试文本如下</span><br><span class="line">[root@localhost ~]# cat Sed.txt</span><br><span class="line">this is line 1,this is First line</span><br><span class="line">this is line 2,the Second line,Empty line followed</span><br><span class="line"></span><br><span class="line">this is line 4,this is Third line</span><br><span class="line">this is line 5,this is Fifth line</span><br></pre></td></tr></table></figure>
<h3 id="使用-e或分号连接多个命令"><a href="#使用-e或分号连接多个命令" class="headerlink" title="使用-e或分号连接多个命令"></a>使用-e或分号连接多个命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#两个编辑命令前都要使用-e参数，如果有更多的编辑需求，以此类推即可</span><br><span class="line">[root@localhost ~]# sed-e &#39;s&#x2F;this&#x2F;That&#x2F;g&#39;-e &#39;s&#x2F;line&#x2F;LINE&#x2F;g&#39; Sed.txt</span><br><span class="line">That is LINE 1,That is First LINE</span><br><span class="line">That is LINE 2,the Second LINE,Empty LINE followed</span><br><span class="line"></span><br><span class="line">That is LINE 4,That is Third LINE</span><br><span class="line">That is LINE 5,That is Fifth LINE</span><br><span class="line"></span><br><span class="line">#使用分号连接两个都编辑命令</span><br><span class="line">#上面的命令可以用分号改写为：</span><br><span class="line">[root@localhost ~]# sed &#39;s&#x2F;this&#x2F;That&#x2F;g ; s&#x2F;line&#x2F;LINE&#x2F;g&#39; Sed.txt</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="删除第一行"><a href="#删除第一行" class="headerlink" title="删除第一行"></a>删除第一行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#将file的第一行删除后输出到屏幕</span><br><span class="line">[root@localhost ~]# sed &#39;1d&#39; Sed.txt</span><br><span class="line">this is line 2,the Second line,Empty line followed</span><br><span class="line"></span><br><span class="line">this is line 4,this is Third line</span><br><span class="line">this is line 5,this is Fifth line</span><br><span class="line"></span><br><span class="line">#如果想直接修改文件，使用-i参数</span><br><span class="line">#这里不会有任何输出，而是直接修改了源文件，删除了第一行</span><br><span class="line">sed -i &#39;1d&#39; file</span><br></pre></td></tr></table></figure>

<h4 id="删除指定范围的行"><a href="#删除指定范围的行" class="headerlink" title="删除指定范围的行"></a>删除指定范围的行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除指定范围的行（第1行到第5行）</span><br><span class="line">[root@localhost ~]# sed &#39;1,3d&#39; Sed.txt</span><br><span class="line">this is line 4,this is Third line</span><br><span class="line">this is line 5,this is Fifth line</span><br><span class="line"></span><br><span class="line">#删除指定范围的行（第一行到最后行）</span><br><span class="line">[root@localhost ~]# sed &#39;1,$d&#39; Sed.txt</span><br><span class="line">[root@localhost ~]#   </span><br><span class="line"></span><br><span class="line">#清空了Sed.txt文件</span><br><span class="line">#删除最后一行</span><br><span class="line">[root@localhost ~]# sed &#39;$d&#39; Sed.txt</span><br><span class="line">this is line 1,this is First line</span><br><span class="line"></span><br><span class="line">this is line 2,the Second line,Empty line followed this is line 4,this is Third line</span><br></pre></td></tr></table></figure>
<h4 id="删除指定范围以外的行"><a href="#删除指定范围以外的行" class="headerlink" title="删除指定范围以外的行"></a>删除指定范围以外的行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除除指定范围以外的行（只保留第5行）</span><br><span class="line">[root@localhost ~]# sed &#39;5!d&#39; Sed.txt</span><br><span class="line">this is line 5,this is Fifth line</span><br></pre></td></tr></table></figure>
<h4 id="删除正则匹配的行"><a href="#删除正则匹配的行" class="headerlink" title="删除正则匹配的行"></a>删除正则匹配的行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#删除所有包含Empty的行</span><br><span class="line">[root@localhost ~]# sed &#39;&#x2F;Empty&#x2F;d&#39; Sed.txt</span><br><span class="line">this is line 1,this is First line</span><br><span class="line"></span><br><span class="line">this is line 4,this is Third line</span><br><span class="line">this is line 5,this is Fifth line</span><br></pre></td></tr></table></figure>
<h4 id="删除空行"><a href="#删除空行" class="headerlink" title="删除空行"></a>删除空行</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#39;&#x2F;^$&#x2F;d&#39; Sed.txt</span><br><span class="line">this is line 1,this is First line</span><br><span class="line">this is line 2,the Second line,Empty line followed</span><br><span class="line">this is line 4,this is Third line</span><br><span class="line">this is line 5,this is Fifth line</span><br></pre></td></tr></table></figure>
<h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><p>使用s命令可将查找到的匹配文本内容替换为新的文本。</p>
<h4 id="默认替换每行第一个"><a href="#默认替换每行第一个" class="headerlink" title="默认替换每行第一个"></a>默认替换每行第一个</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#s命令用于替换文本，本例中使用LINE替换line</span><br><span class="line">#请注意每一行只有第一个line被替换了，默认情况下只替换第一次匹配到的内容</span><br><span class="line">#替换并打印</span><br><span class="line">[root@localhost ~]# sed &#39;s&#x2F;line&#x2F;LINE&#x2F;&#39; Sed.txt</span><br><span class="line">this is LINE 1,this is First line</span><br><span class="line">this is LINE 2,the Second line,Empty line followed</span><br><span class="line"></span><br><span class="line">this is LINE 4,this is Third line</span><br><span class="line">this is LINE 5,this is Fifth line</span><br></pre></td></tr></table></figure>
<h4 id="替换每行前两个"><a href="#替换每行前两个" class="headerlink" title="替换每行前两个"></a>替换每行前两个</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#要想每行最多匹配2个line，并改为LINE，可用如下方式</span><br><span class="line">#注意到第2行中有3个line，前两个被替换了，第三个没有变化</span><br><span class="line">[root@localhost ~]# sed &#39;s&#x2F;line&#x2F;LINE&#x2F;2&#39; Sed.txt</span><br><span class="line">this is line 1,this is First LINE</span><br><span class="line">this is line 2,the Second LINE,Empty line followed</span><br><span class="line"></span><br><span class="line">this is line 4,this is Third LINE</span><br><span class="line">this is line 5,this is Fifth LINE</span><br></pre></td></tr></table></figure>
<h4 id="替换所有匹配"><a href="#替换所有匹配" class="headerlink" title="替换所有匹配"></a>替换所有匹配</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#s命令利用g选项，可以完成所有匹配值的替换</span><br><span class="line">[root@localhost ~]# sed &#39;s&#x2F;line&#x2F;LINE&#x2F;g&#39; Sed.txt</span><br><span class="line">this is LINE 1,this is First LINE</span><br><span class="line">this is LINE 2,the Second LINE,Empty LINE followed</span><br><span class="line"></span><br><span class="line">this is LINE 4,this is Third LINE</span><br><span class="line">this is LINE 5,this is Fifth LINE</span><br></pre></td></tr></table></figure>
<h4 id="替换开头"><a href="#替换开头" class="headerlink" title="替换开头"></a>替换开头</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只替换开头的this为that</span><br><span class="line">[root@localhost ~]# sed &#39;s&#x2F;^this&#x2F;that&#x2F;&#39; Sed.txt</span><br><span class="line">that is line 1,this is First line</span><br><span class="line">that is line 2,the Second line,Empty line followed</span><br><span class="line"></span><br><span class="line">that is line 4,this is Third line</span><br><span class="line">that is line 5,this is Fifth line</span><br></pre></td></tr></table></figure>
<h3 id="字符转换"><a href="#字符转换" class="headerlink" title="字符转换"></a>字符转换</h3><p>类似于perl的tr<br>使用y命令可进行字符转换，其作用为将一系列字符逐个地变换为另外一系列字符，基本用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#该命令会将file中的O转换为N、L转换为E、D转换为W</span><br><span class="line">#注意转换字符和被转换字符的长度要相等，否则sed无法执行</span><br><span class="line">sed  &#39;y&#x2F;OLD&#x2F;NEW&#x2F;&#39; file</span><br></pre></td></tr></table></figure>
<p>下面的命令演示了将数字1转换为A，2转换为B，4转换为C，5转换成D的用法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#39;y&#x2F;1245&#x2F;ABCD&#x2F;&#39; Sed.txt</span><br><span class="line">this is line A,this is First line</span><br><span class="line">this is line B,the Second line,Empty line followed</span><br><span class="line">this is line C,this is Third line</span><br><span class="line">this is line D,this is Fifth line</span><br></pre></td></tr></table></figure>
<h3 id="匹配并插入文本"><a href="#匹配并插入文本" class="headerlink" title="匹配并插入文本"></a>匹配并插入文本</h3><p>使用i或a命令插入文本，其中i代表在匹配行之前插入，而a代表在匹配行之后插入，示例如下：</p>
<h4 id="匹配行之前插入文本"><a href="#匹配行之前插入文本" class="headerlink" title="匹配行之前插入文本"></a>匹配行之前插入文本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用i在第二行前插入文本</span><br><span class="line">[root@localhost ~]# sed &#39;2 i Insert&#39; Sed.txt</span><br><span class="line">this is line 1,this is First line</span><br><span class="line">Insert</span><br><span class="line">this is line 2,the Second line,Empty line followed</span><br><span class="line"></span><br><span class="line">this is line 4,this is Third line</span><br><span class="line">this is line 5,this is Fifth line</span><br></pre></td></tr></table></figure>
<h4 id="匹配行后插入文本"><a href="#匹配行后插入文本" class="headerlink" title="匹配行后插入文本"></a>匹配行后插入文本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#使用a在第二行后插入文本</span><br><span class="line">[root@localhost ~]# sed &#39;2 a Insert&#39; Sed.txt</span><br><span class="line">this is line 1,this is First line</span><br><span class="line">this is line 2,the Second line,Empty line followed</span><br><span class="line">Insert</span><br><span class="line"></span><br><span class="line">this is line 4,this is Third line</span><br><span class="line">this is line 5,this is Fifth line</span><br></pre></td></tr></table></figure>
<h4 id="匹配行的上一行插入文本"><a href="#匹配行的上一行插入文本" class="headerlink" title="匹配行的上一行插入文本"></a>匹配行的上一行插入文本</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#在匹配行的上一行插入问题</span><br><span class="line">[root@localhost ~]# sed &#39;&#x2F;Second&#x2F;i\Insert&#39; Sed.txt</span><br><span class="line">this is line 1,this is First line</span><br><span class="line">Insert</span><br><span class="line">this is line 2,the Second line,Empty line followed</span><br><span class="line"></span><br><span class="line">this is line 4,this is Third line</span><br><span class="line">this is line 5,this is Fifth line</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>文本处理工具awk</title>
    <url>/2019/12/24/awk/</url>
    <content><![CDATA[<p>awk每行为一条记录，每条记录执行awk的所有命令。每行默认以空格或tab键分割，依次为$1,$2,$3 …。NR代表每行的行号，NF代表每列tab或空格分割后有几列。</p>
<a id="more"></a>
<h2 id="字段分隔符"><a href="#字段分隔符" class="headerlink" title="字段分隔符"></a>字段分隔符</h2><p>字段分隔符默认是空格或tab，通过-F参数可以修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[bio@ubuntu ~]$ ll |grep ^d</span><br><span class="line">drwxr-xr-x 45 bio  bio     4096  5月 22 13:34 ./</span><br><span class="line">drwxr-xr-x  3 root root    4096  1月 20 19:40 ../</span><br><span class="line">drwx------  3 bio  bio     4096  5月 22 11:44 .adobe/</span><br><span class="line">drwxrwxr-x  3 bio  bio     4096  3月 16 12:50 .aspera/</span><br><span class="line">drwxrwxr-x  2 bio  bio     4096  5月 21 17:58 bash/</span><br><span class="line">drwx------ 25 bio  bio     4096  5月  7 14:21 .cache/</span><br><span class="line">drwxrwxr-x  3 bio  bio     4096  2月 27 11:24 .codeintel/</span><br><span class="line">drwx------  3 bio  bio     4096  1月 20 20:19 .compiz/</span><br><span class="line">drwxr-xr-x 28 bio  bio     4096  5月  9 11:37 .config/</span><br><span class="line">drwxr-xr-x  6 root root    4096  4月  8 16:56 .cpan/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字段分隔符改为冒号</span></span><br><span class="line">[bio@ubuntu ~]$ ll |grep ^d|awk -F: <span class="string">'&#123;print $1&#125;'</span></span><br><span class="line">drwxr-xr-x 45 bio  bio     4096  5月 22 13</span><br><span class="line">drwxr-xr-x  3 root root    4096  1月 20 19</span><br><span class="line">drwx------  3 bio  bio     4096  5月 22 11</span><br><span class="line">drwxrwxr-x  3 bio  bio     4096  3月 16 12</span><br><span class="line">drwxrwxr-x  2 bio  bio     4096  5月 21 17</span><br><span class="line">drwx------ 25 bio  bio     4096  5月  7 14</span><br><span class="line">drwxrwxr-x  3 bio  bio     4096  2月 27 11</span><br><span class="line">drwx------  3 bio  bio     4096  1月 20 20</span><br><span class="line">drwxr-xr-x 28 bio  bio     4096  5月  9 11</span><br><span class="line">drwxr-xr-x  6 root root    4096  4月  8 16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字段分隔符有两个：冒号和i。中括号内可以使用正则表达式</span></span><br><span class="line">[bio@ubuntu ~]$ ll |grep ^d|awk -F‘[:i]’ <span class="string">'&#123;print $1,$2&#125;'</span></span><br><span class="line">drwxr-xr-x 45 b o  b</span><br><span class="line">drwxr-xr-x  3 root root    4096  1月 20 19 40 ../</span><br><span class="line">drwx------  3 b o  b</span><br><span class="line">drwxrwxr-x  3 b o  b</span><br><span class="line">drwxrwxr-x  2 b o  b</span><br></pre></td></tr></table></figure>

<h2 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h2><p>awk在处理文件的行之前先执行BEGIN块的语句，未完成则不读取文件内容。作用如下：</p>
<ul>
<li>更改内置变量；</li>
<li>自定义变量初始化；</li>
<li>打印头文件和标题；</li>
</ul>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><ul>
<li>FS：字段分隔符；</li>
<li>OFS：输出时的字段分隔符；</li>
<li>RS：输入记录的行分隔符；</li>
<li>ORS：输出时的行分隔符；</li>
<li>NR：行号；</li>
<li>FNR：文件的所有行数；</li>
<li>NF：每行列数；</li>
<li>ARGC：命令行参数个数；</li>
<li>ARGV：命令行参数组成的数组；</li>
<li>FILENAME：当前输入文件的名字；</li>
<li>IGNORECASE：1表示忽略大小写；（测试了一下貌似不管用）</li>
</ul>
<h2 id="运算符-和–"><a href="#运算符-和–" class="headerlink" title="运算符++和–"></a>运算符++和–</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当++作为后缀时，先将x的值赋值给y，再对x加1</span></span><br><span class="line">[bio@ubuntu ~/bash]$ awk <span class="string">'BEGIN&#123;x=1;y=x++;print x, y&#125;'</span></span><br><span class="line">2 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当++为前缀时，先x的值加1，然后x赋值给y</span></span><br><span class="line">[bio@ubuntu ~/bash]$ awk <span class="string">'BEGIN&#123;x=1;y=++x;print x, y&#125;'</span></span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux相关</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>文本处理</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Aspera从NCBI或EBI高速下载SRA测序文件</title>
    <url>/2019/12/24/aspera/</url>
    <content><![CDATA[<p>Aspera提供了大文件高速传输方案，适合于大数据的传输。客服端的使用是免费的。</p>
<a id="more"></a>
<h3 id="Aspera下载和安装"><a href="#Aspera下载和安装" class="headerlink" title="Aspera下载和安装"></a>Aspera下载和安装</h3><p>下载地址，有windows和Linux版的，下面安装的是Linux版的，因为后续处理sra文件都是在Linux上操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[bio@ubuntubio]$ wget http://download.asperasoft.com/download/sw/connect/3.7.4/aspera-connect-3.7.4.147727-linux-64.tar.gz</span><br><span class="line">[bio@ubuntubio]$ tar -zxf aspera-connect-3.7.4.147727-linux-64.tar.gz</span><br><span class="line">[bio@ubuntubio]$ bash aspera-connect-3.7.4.147727-linux-64.sh</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">Installing Aspera Connect</span><br><span class="line"> </span><br><span class="line">Deploying Aspera Connect (/home/bio/.aspera/connect) <span class="keyword">for</span> the current user only.</span><br><span class="line">Unable to update desktop database, Aspera Connect may not be able to auto-launch</span><br><span class="line">Restart firefox manually to load the Aspera Connect plug-in</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">[bio@ubuntu~]$ <span class="built_in">echo</span> <span class="string">'PATH=$PATH:~/.aspera/connect/bin/'</span> &gt;&gt; ~/.bashrc</span><br><span class="line">[bio@ubuntu~]$ <span class="built_in">source</span> .bashrc</span><br></pre></td></tr></table></figure>

<h3 id="Aspera-使用"><a href="#Aspera-使用" class="headerlink" title="Aspera 使用"></a>Aspera 使用</h3><h4 id="ascp-常用的参数如下："><a href="#ascp-常用的参数如下：" class="headerlink" title="ascp 常用的参数如下："></a>ascp 常用的参数如下：</h4><ul>
<li>-T：不进行加密。若不添加此参数，可能会下载不了。</li>
<li>-l：设置最大传输速度，比如设置为 200M 则表示最大传输速度为 200m/s。若不设置该参数，则一般可达到10m/s的速度，而设置了，传输速度可以更高。</li>
<li>-i：输入私钥。安装 aspera 后有在目录 ~/.aspera/connect/etc/ 下有几个私钥，使用 linux 服务器的时候一般使用 asperaweb_id_dsa.openssh 文件作为私钥。</li>
<li>–host=string：ftp的host名，NCBI的为ftp-private.ncbi.nlm.nih.gov；EBI的为fasp.sra.ebi.ac.uk。</li>
<li>–user=string：用户名，NCBI的为anonftp，EBI的为era-fasp</li>
<li>–mode=string：选择模式。上传为 send，下载recv</li>
</ul>
<h4 id="从NCBI下载SRA文件"><a href="#从NCBI下载SRA文件" class="headerlink" title="从NCBI下载SRA文件"></a>从NCBI下载SRA文件</h4><p>例如要下载<a href="ftp://ftp.ncbi.nlm.nih.gov/sra/sra-instant/reads/ByRun/sra/ERR/ERR188/ERR188245/ERR188245.sra" target="_blank" rel="noopener">ftp://ftp.ncbi.nlm.nih.gov/sra/sra-instant/reads/ByRun/sra/ERR/ERR188/ERR188245/ERR188245.sra</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[bio@ubuntu~]<span class="variable">$ascp</span> -T -l 200M -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh anonftp@ftp-private.ncbi.nlm.nih.gov:/sra/sra-instant/reads/ByRun/sra/ERR/ERR188/ERR188245/ERR188245.sra ./</span><br></pre></td></tr></table></figure>

<h4 id="从EBI下载SRA文件"><a href="#从EBI下载SRA文件" class="headerlink" title="从EBI下载SRA文件"></a>从EBI下载SRA文件</h4><p>例如要下载<a href="ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR188/ERR188245/ERR188245_1.fastq.gz" target="_blank" rel="noopener">ftp://ftp.sra.ebi.ac.uk/vol1/fastq/ERR188/ERR188245/ERR188245_1.fastq.gz</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[bio@ubuntu~]$ ascp -P33001 -T -l 200M -i ~/.aspera/connect/etc/asperaweb_id_dsa.openssh era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/ERR188/ERR188245/ERR188245_1.fastq.gz ./</span><br></pre></td></tr></table></figure>

<p>-P33001：EBI这个参数是必须的，但是NCBI不需要，要不然会报错Session Stop (Error: Failed to open TCP connection for SSH)</p>
]]></content>
      <categories>
        <category>生物信息学常用软件</category>
      </categories>
      <tags>
        <tag>生信软件</tag>
        <tag>下载SRA文件</tag>
      </tags>
  </entry>
  <entry>
    <title>kobas 富集分析超快超速度</title>
    <url>/2019/12/21/kobas/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>富集分析一般是高通量实验，如基因芯片，RNA-Seq，蛋白质组学（质谱结果）的后续分析步骤。常见的就是GO功能注释和KEGG通路富集分析。通过基因通路富集分析，我们可以初步分析基因可能参与的生物学过程或者信号通路。</p>
<p>富集分析的工具有很多，DAVID，STRING，Kobas，R语言等。其中DAVID在2016年以后就很少更新了；String是瑞士苏黎世大学构建的一个搜寻蛋白质之间相互作用的数据库；R语言则语言有一定的编程基础；Kobas是用于注释富集途径和疾病的数据库，有在线版的也有服务器版的，在线的易用，服务器版的速度，不管你是生信小白或者大神都适用哦。</p>
<a id="more"></a>
<h3 id="Kobas简介"><a href="#Kobas简介" class="headerlink" title="Kobas简介"></a>Kobas简介</h3><p>KOBAS（KEGG Orthology Based Annotation System)，(<a href="http://kobas.cbi.pku.edu.cn/index.php" target="_blank" rel="noopener">http://kobas.cbi.pku.edu.cn/index.php</a> )是北京大学开发的用于基因、蛋白质功能注释和功能基因富集分析的web服务器。现在版本已经更新到Kobas 3.0，注释的数据库包括pathway、disease和GO。Kobas 3.0主要有两个功能，注释（Annotation）和富集（Enrichment）。富集又包括Gene-list富集和Exp-data富集。</p>
<h3 id="Kobas的优点"><a href="#Kobas的优点" class="headerlink" title="Kobas的优点"></a>Kobas的优点</h3><p>KOBAS有以下几个优点：</p>
<ol>
<li>Gene-list富集输入的可以是核苷酸序列也可以是蛋白质序列，还可以是tab分隔的blast结果，还可以是NCBI Entrez Gene ID、RefSeq Protein ID、Ensembl Gene ID、UniprotKB AC/ID </li>
<li>Kobas支持的物种有4000多种，不限于模式生物</li>
<li>统计检验方法有Fisher’s exact test和hypergeometric distribution test</li>
<li>底层的数据库数据每3个月更新一次</li>
</ol>
<h3 id="在线分析实例"><a href="#在线分析实例" class="headerlink" title="在线分析实例"></a>在线分析实例</h3><h4 id="Gene-list富集分析"><a href="#Gene-list富集分析" class="headerlink" title="Gene-list富集分析"></a>Gene-list富集分析</h4><ol>
<li><p>点击圈红的Gene-list Enrichment进去；<br><img src="/images/1.jpg" alt="image"></p>
</li>
<li><p>Input<br><img src="/images/1.1.jpg" alt="image"></p>
</li>
</ol>
<ul>
<li>首先选择Gene-list的类型。可以是NCBI Entrez Gene ID、RefSeq Protein ID、Ensembl Gene ID、UniprotKB AC/ID；也可以是核苷酸或蛋白质的Fasta序列；还可以是Tab分隔的BLAST结果。</li>
<li>然后选择类型对应的物种，默认物种是人。</li>
<li>然后输入对应类型的Gene-list。</li>
<li>选择富集分析需要的数据库，</li>
</ul>
<ol start="3">
<li>点击Run显示以下信息，程序在后台运行。<br><img src="/images/0.jpg" alt="image"></li>
<li>运行完毕得出以下结果。点击Download可以下载结果列表。列表有以下几个列：<br><img src="/images/2.jpg" alt="image"></li>
</ol>
<ul>
<li>Term：KEGG pathway通路名称或GO Term功能的描述；</li>
<li>Database：分析时所选的数据库，这里是GO和KEGG；</li>
<li>ID：指富集到的对应数据库的ID条目；</li>
<li>Input number：Gene-list落在该通路或GO term的基因数目；</li>
<li>Background number：该通路或GO Term相关的基因数目；</li>
<li>P-value：富集到该通路的显著性水平，越小越显著；</li>
<li>Corrected P-value：矫正的P-value，列表默认按照Corrected P-value由小到大排序。</li>
</ul>
<h4 id="Exp-data富集分析"><a href="#Exp-data富集分析" class="headerlink" title="Exp-data富集分析"></a>Exp-data富集分析</h4><p><img src="/images/3.jpg" alt="image"><br>基因表达数据分析需要输入两个文件，一个是表达矩阵文件，一个是样本分类文件。</p>
<ul>
<li>表达矩阵的格式如下图：是一个tab分隔的txt文件，列对应样本，行对应基因ID。表达数据既可以是芯片表达矩阵，也可以是RNA-seq表达矩阵。芯片数据可以是raw reads数据，而RNA-seq数据只能是FPKM/RPKM数据，不能是raw reads。<br><img src="/images/4.jpg" alt="image"></li>
<li>样本分类如下图：<br><img src="/images/5.png" alt="image"></li>
<li>输出结果有五列：<br><img src="/images/6.jpg" alt="image"><ul>
<li>GENE SET：指富集到的通路编号或GO Term编号；</li>
<li>NAME：指富集到的KEGG pathway通路名称或GO Term功能的描述；</li>
<li>POSITIVE：1.0代表显著富集；</li>
<li>PROBABILITY：代表预测的可信度；</li>
<li>ENRICH SCORE：指目标通路与separating hyperplane of SVM的距离，数值越大越好；</li>
</ul>
</li>
</ul>
<h3 id="KOBAS本地化"><a href="#KOBAS本地化" class="headerlink" title="KOBAS本地化"></a>KOBAS本地化</h3><p>安装KOBAS需要先安装一些依赖的python包、R包以及相关软件。</p>
<h4 id="1、依赖的python包"><a href="#1、依赖的python包" class="headerlink" title="1、依赖的python包"></a>1、依赖的python包</h4><p>安装KOBAS 3.0 需要Python (&gt;= 2.3 and not 3.x)，并且需要安装以下第三方包：</p>
<ul>
<li>SQLite (3.x) and PySQLite (2.x)</li>
<li>BioPython (&gt;= 1.4.3)</li>
<li>RPy2 (&gt;= 2.2.4)</li>
<li>matplotlib </li>
<li>Numpy (&gt;= 1.8.0)</li>
<li>Pandas (&gt;= 0.17.1)</li>
</ul>
<h4 id="2、依赖的R包"><a href="#2、依赖的R包" class="headerlink" title="2、依赖的R包"></a>2、依赖的R包</h4><p>安装KOBAS 3.0 需要R (&gt;= 2.0)，并且需要安装如下第三方包：</p>
<ul>
<li>QVALUE</li>
<li>EnrichmentBrowser</li>
<li>GSVA</li>
<li>gage</li>
</ul>
<h4 id="3、其他软件"><a href="#3、其他软件" class="headerlink" title="3、其他软件"></a>3、其他软件</h4><p>安装KOBAS 3.0 需要安装NCBI BLAST+</p>
<p>Download: <a href="ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/" target="_blank" rel="noopener">ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/</a></p>
<p>Installation: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zvf ncbi-blast-x.x.x+-x64-linux.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/ncbi-blast-2.2.29+/bin"</span>  </span><br><span class="line"><span class="comment">#(or add path to your .bashrc)</span></span><br></pre></td></tr></table></figure>

<h4 id="4、安装KOBAS"><a href="#4、安装KOBAS" class="headerlink" title="4、安装KOBAS"></a>4、安装KOBAS</h4><p>首先，下载KOBAS 3.0 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://kobas.cbi.pku.edu.cn/kobas-2.1.1/kobas-3.0.3.tar.gz</span><br><span class="line">tar -zxf kobas-3.0.3.tar.gz</span><br><span class="line"><span class="comment"># 解压就能用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########解压后的文件结构#########</span></span><br><span class="line">kobas-3.0.3/</span><br><span class="line">		|-----README : introduce how to install kobas and how to use it.</span><br><span class="line"></span><br><span class="line">		|-----scripts : run KOBAS program.</span><br><span class="line"></span><br><span class="line">		|-----seq_pep : store FASTA format protein sequence files of KO and all supported species </span><br><span class="line"></span><br><span class="line">		|-----sqlite3 : store backend databases of KO and all supported species </span><br><span class="line"></span><br><span class="line">		|-----src : store KOBAS <span class="built_in">source</span> codes.</span><br><span class="line"></span><br><span class="line">		|-----<span class="built_in">test</span> : store example data <span class="keyword">for</span> testing KOBAS.</span><br><span class="line"><span class="comment">#################################</span></span><br></pre></td></tr></table></figure>

<p>然后，下载KOBAS数据包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">########KOBAS organism data package########</span></span><br><span class="line">wget ftp://ftp.cbi.pku.edu.cn/pub/KOBAS_3.0_DOWNLOAD/sqlite3/organism.db.gz</span><br><span class="line">gunzip organism.db.gz <span class="comment">#复制到 sqlite3 目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########下载自己需要的物种#################</span></span><br><span class="line">wget ftp://ftp.cbi.pku.edu.cn/pub/KOBAS_3.0_DOWNLOAD/sqlite3/hsa.db.gz</span><br><span class="line">gunzip hsa.db.gz  <span class="comment">#复制到sqlite3 目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########下载对应物种的pep序列##############</span></span><br><span class="line">wget ftp://ftp.cbi.pku.edu.cn/pub/KOBAS_3.0_DOWNLOAD/seq_pep/hsa.pep.fasta.gz</span><br><span class="line">gunzip hsa.pep.fasta.gz  <span class="comment">#复制到seq_pep 目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########建blast数据库######################</span></span><br><span class="line">makeblastdb -<span class="keyword">in</span> hsa.pep.fasta -dbtype prot</span><br></pre></td></tr></table></figure>

<p>最后，配置KOBAS运行环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PYTHONPATH = kobas-3.0.0-beta/src:<span class="variable">$PYTHONPATH</span></span><br><span class="line"></span><br><span class="line">cp kobas-3.0/docs/kobasrc  ~/.kobasrc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim .kobasrc <span class="comment">#编辑配置文件</span></span><br><span class="line"><span class="comment">######.kobasrc文件内容如下#########</span></span><br><span class="line">---------------------------	</span><br><span class="line"></span><br><span class="line">	[DEFAULT]</span><br><span class="line"></span><br><span class="line">	kobas_home = <span class="variable">$HOME</span>/kobas-3.0.3/	<span class="comment"># kobas 的绝对路径</span></span><br><span class="line"></span><br><span class="line">	blast_home = <span class="variable">$HOME</span>/ncbi-blast-2.2.29+/bin</span><br><span class="line"></span><br><span class="line">	[KOBAS]</span><br><span class="line"></span><br><span class="line">	kobasdb	= %(kobas_home)s/sqlite3/	<span class="comment"># path to Backend databases of KO and all supported species, if you don't want to state it by kobas_home, # you can also write the absolute path after "="</span></span><br><span class="line"></span><br><span class="line">	[BLAST]</span><br><span class="line"></span><br><span class="line">	blastp = %(blast_home)s/blastp		<span class="comment"># path to program blastp</span></span><br><span class="line">	blastx = %(blast_home)s/blastx		<span class="comment"># path to program blastx</span></span><br><span class="line">	blastdb = %(kobas_home)s/seq_pep/	<span class="comment"># path to FASTA format protein sequence files of KO and all supported species</span></span><br><span class="line"></span><br><span class="line"> -----------------------------</span><br></pre></td></tr></table></figure>

<p> Kobas的使用</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment">### 注释</span></span><br><span class="line">$ annotate.py -i inputfile -t blastout:tab -s ko -o outfile</span><br><span class="line"><span class="comment"># -t：输入文件的类型，有blastout:tab和blastout:xml，fasta:pro，fasta:nuc,id:ncbigene,id:refseqpro,id:uniport,id:ensembl</span></span><br><span class="line"><span class="comment"># -s：物种类型，ko指KEGG Orthology，has人，mmu 小鼠，等等</span></span><br><span class="line"><span class="comment"># -k：KOBAS home</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 检测</span></span><br><span class="line">$ identify.py -f inputfile -o outfile -m h </span><br><span class="line"> <span class="comment">#identify的inputfile是annotate的outfile</span></span><br><span class="line"><span class="comment"># -m：统计检验方法，c代表chi-square test，h代表hypergeometric test/ Fisher's exact test，x代表frequency list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###富集</span></span><br><span class="line">$ cluster.py -i inputfile -m k -o outfile </span><br><span class="line"><span class="comment"># -m：method，K表示 Cohen’s kappa coefficient；j表示jaccard similarity coefficient</span></span><br><span class="line"><span class="comment"># -d：database，P代表PATHWAY，D代表DISEASE，G代表GO</span></span><br><span class="line"><span class="comment"># -t：threshold,默认0.35</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<p><a href="http://kobas.cbi.pku.edu.cn/help.php" target="_blank" rel="noopener">http://kobas.cbi.pku.edu.cn/help.php</a><br><a href="https://www.jianshu.com/p/5a4bda169247" target="_blank" rel="noopener">https://www.jianshu.com/p/5a4bda169247</a></p>
]]></content>
      <categories>
        <category>生物信息学常用软件</category>
      </categories>
      <tags>
        <tag>富集分析</tag>
        <tag>生信软件</tag>
        <tag>python软件</tag>
      </tags>
  </entry>
</search>
